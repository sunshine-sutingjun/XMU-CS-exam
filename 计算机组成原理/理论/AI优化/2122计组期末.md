# 一、（20分）计算

## 1. IEEE754编码表示的单精度浮点数为(BED00000)H，其对应的十进制数真值是多少？

**1. 十六进制转二进制（标注 S/E/M 字段）：**
将 $(BED00000)_H$ 展开为 32 位二进制：
$$
\underbrace{1}_{S} \ \underbrace{01111101}_{E} \ \underbrace{10100000000000000000000}_{M}
$$

**2. 提取字段值：**

* **S (符号位)**：$1$ $\rightarrow$ 负数。
* **E (阶码)**：$(01111101)_2 = 125$。
* **M (尾数)**：$1010...0$。

**3. 计算指数真值 (e)：**

* $e = E - 127 = 125 - 127 = -2$

**4. 恢复规格化尾数 (1.M)：**

* 加上隐含位 1，得到二进制数 $(1.101)_2$。
* 转换十进制：$1 + 0.5 + 0.125 = 1.625$。

**5. 计算最终真值：**

* 真值 $= -1.625 \times 2^{-2} = -1.625 \times 0.25 = -0.40625$

**最终结论：**
该单精度浮点数的真值为 **$-0.40625$**。

## 将 -131.75 表示成IEEE754编码表示的单精度浮点数（以8位16进制数格式表示）

**1. 十进制转二进制：**

* 符号：负数，故 $S = 1$。
* 整数部分：$131 = 128 + 2 + 1 = (10000011)_2$。
* 小数部分：$0.75 = 0.5 + 0.25 = (0.11)_2$。
* 合并：$-131.75 = -(10000011.11)_2$。

**2. 规格化处理：**

* 向左移动小数点，使其变为 $1.M$ 的形式：
  $10000011.11 = 1.000001111 \times 2^7$
* 此时：真实指数 $e = 7$，尾数 $M = 000001111$（省略开头的1.）。

**3. 计算阶码 (E)：**

* 公式：$E = e + 127$
* 计算：$E = 7 + 127 = 134$
* 转二进制：$(134)_{10} = (10000110)_2$。

**4. 拼接并标注 S/E/M 字段：**

* 拼接 $S(1位) + E(8位) + M(23位)$，不足23位在右侧补0：

$$
\underbrace{1}_{S} \ \underbrace{10000110}_{E} \ \underbrace{00000111100000000000000}_{M}
$$

**5. 二进制转十六进制：**

* 每4位一组进行转换：
  `1100` `0011` `0000` `0011` `1100` `0000` `0000` `0000`
  ` C ` ` 3 ` ` 0 ` ` 3 ` ` C ` ` 0 ` ` 0 ` ` 0 `

**最终结论：**
$-131.75$ 的 IEEE 754 单精度浮点数编码为 **$(C303C000)_H$**。

## 2. 某浮点数字长16位，阶码5位（含1位阶符），尾数11位（含1位数符），均以补码表示

**1. 规格化补码的定义：**

* **规格化正数**：补码形式为 $0.1xxxxxxxxxx...$（真值范围在 $[1/2, 1-2^{-10}]$ 之间）。
* **规格化负数**：补码形式为 $1.0xxxxxxxxxx...$（真值范围在 $[-1, -(1/2+2^{-10})]$ 之间）。

**2. 最大规格化负数：**

* **定义**：在负数范围内，数值最大即绝对值最小。
* **阶码 (E)**：要使数值最大，阶码应取补码能表示的最小值。5位补码最小值为 $10000$（十进制为 $-16$）。
* **尾数 (M)**：规格化负数补码最大值为 $1.0111111111$。
  * 该尾数真值为：$-1 + (0.0111111111)_2 = -(0.1000000001)_2 = -(2^{-1} + 2^{-10})$。
* **计算**：
    $$真值 = 尾数 \times 2^{阶码} = -(2^{-1} + 2^{-10}) \times 2^{-16}$$

**3. 最大规格化正数：**

* **定义**：数值最大，即阶码取最大，尾数取最大。
* **阶码 (E)**：5位补码最大值为 $01111$（十进制为 $15$）。
* **尾数 (M)**：规格化正数补码最大值为 $0.1111111111$。
  * 该尾数真值为：$1 - 2^{-10}$。
* **计算**：
    $$真值 = 尾数 \times 2^{阶码} = (1 - 2^{-10}) \times 2^{15}$$

**最终结论：**

* 最大规格化负数二进制编码为：`10000, 1.0111111111`，真值为 $-(2^{-1} + 2^{-10}) \times 2^{-16}$。
* 最大规格化正数二进制编码为：`01111, 0.1111111111`，真值为 $(1 - 2^{-10}) \times 2^{15}$。

## 3. 设 x = -0.01011，y = 0.11001，用加减交替法计算 x÷y，结果保留4位小数

**1. 参数准备：**

* **符号位**：$S_x \oplus S_y = 1 \oplus 0 = 1$（结果为负）。
* **操作数**：$|x| = 0.01011$，$|y| = 0.11001$。
* **补码形式**：
  * $[|y|]_{补} = 00.11001$
  * $[-|y|]_{补} = 11.00111$

**2. 竖式运算过程：**

      00.01011      (被除数 |x|)
    + 11.00111      (步1：加 [-|y|]补)
    ----------
      11.01110      (余数 R0 < 0，商 q0 = 0)

    ← 11.11100      (R0 左移一位)
    + 00.11001      (步2：R0 < 0，故加 [|y|]补)
    ----------
      00.10101      (余数 R1 > 0，商 q1 = 1)

    ← 01.01010      (R1 左移一位)
    + 11.00111      (步3：R1 > 0，故加 [-|y|]补)
    ----------
      00.01101      (余数 R2 > 0，商 q2 = 1)

    ← 00.11010      (R2 左移一位)
    + 11.00111      (步4：R2 > 0，故加 [-|y|]补)
    ----------
      11.11101      (余数 R3 < 0，商 q3 = 0)

    ← 11.11010      (R3 左移一位)
    + 00.11001      (步5：R3 < 0，故加 [|y|]补)
    ----------
      00.10011      (余数 R4 > 0，商 q4 = 1)

**3. 结果汇总：**

* **商 (Q)**：
  根据符号位 S=1，商的绝对值为 0.0111（对应 q1 q2 q3 q4，若 q4 步后仍有余数需根据题目精度进位或截断）。
  $Q = -0.0111$
* **余数 (R)**：
  余数符号与被除数一致（负），真值为最后一次余数缩放回对应位权。
  $R = -0.00011 \times 2^{-4}$ (具体取决于最后一步的修正逻辑)

## 4. 已知 x=0.125×2^1，y =0.625×2^4，设阶码3位（含1位阶符），尾数5位（含1位数符）。用浮点数运算方法求 x-y 二进制浮点规格化的结果。并对结果进行简要分析

**1. 预处理：将十进制转为机器码**

* **$x$**：
  * 真值：$0.125 \times 2^1 = 0.001 \times 2^1$
  * 浮点形式：阶码 $E_x = 1 (001)$，尾数 $M_x = 0.0010$ (正数补码 $00.0010$)
* **$y$**：
  * 真值：$0.625 \times 2^4 = 0.101 \times 2^4$
  * 浮点形式：阶码 $E_y = 4 (100)$，尾数 $M_y = 0.1010$ (正数补码 $00.1010$)
  * *注：阶码4实际上已超出3位补码范围(最大3)，但此处按中间过程继续运算。*

**2. 标准五步运算：**

**(1) 零操作检查**

* 检查 $x$ 和 $y$ 的尾数是否为0。
* $M_x \neq 0, M_y \neq 0$，故都不是零，必须进行后续处理。

**(2) 对阶 (小阶向大阶看齐)**

* 求阶差：$\Delta E = E_y - E_x = 4 - 1 = 3$。
* 调整 $x$：将 $x$ 的阶码增大至 4，尾数右移 3 位。
  * $M_x (00.0010) \xrightarrow{右移3位} 00.000001$ (保留附加位用于计算)
* 此时：$x = 00.000001 \times 2^4$。

**(3) 尾数相加 (计算 x - y)**

* 转换为加法：$x - y = x + [-y]_{补}$
* 求 $[-y]_{补}$：
  * $[M_y]_{补} = 00.1010$
  * $[-M_y]_{补} = 11.0110$ (连同符号位取反加1)
* 执行加法：
    $$
    \begin{array}{rr}
       00.000001 & (x \text{ 已对阶}) \\
     + 11.011000 & (-y \text{ 补码}) \\
    \hline
       11.011001 & (\text{求和结果})
    \end{array}
    $$
* 结果尾数 $M_{res} = 11.011001$，阶码 $E = 4$。

**(4) 规格化**

* **判别**：补码表示的负数，其规格化形式应为 $11.0xxxx...$ (即符号位与第一数值位不同，或理解为 $1.0...$)。
* **检查**：当前尾数 $11.011001$，符号位为 $11$，第一数值位为 $0$。满足规格化要求。
* **操作**：无需左规或右规。

**(5) 舍入**

* 题目要求：尾数5位（含1位数符，即保留4位小数）。
* 当前尾数：$1.011001$
* **截断**：直接保留前4位小数，丢弃末尾的 $01$。
* 最终尾数：$1.0110$ (补码形式)

**3. 最终结果：**

* **阶码**：$4$ (二进制 $100$)
* **尾数**：$1.0110$
* **结果表示**：$100, 1.0110$

---

### 💡 【结果简要分析】

1. **大数吃小数**：
    * 由于 $y$ 的阶码比 $x$ 大 3，导致 $x$ 在对阶时右移过多，有效数值 $0.001$ 变成了 $0.000001$，在保留4位精度的舍入过程中完全丢失。运算结果实际上等于 $-y$。
2. **阶码上溢 (Overflow)**：
    * 最终阶码为 4。题目限定阶码为 3 位补码，其表示范围是 $[-4, +3]$。
    * 阶码 4 超出了最大允许值 3，发生**上溢**，系统将报错或产生错误结果。

# 二、 存储器扩展设计：构建 8KB 存储系统

## **1. 芯片数量计算 (3分)**

* **BIOS 区 (2K×8位)**：主存空间前 2K 使用 2K×4 位 ROM 芯片，需通过**位扩展**满足 8 位数据要求，因此需要 **2 片**。
* **数据区 (4K×8位)**：主存空间最后面使用 4K×8 位 RAM 芯片，容量与字长均匹配，需要 **1 片**。
* **用户程序区 (2K×8位)**：剩余空间为 $8K - 2K - 4K = 2K$。使用 1K×8 位 RAM 芯片，需通过**字扩展**满足容量要求，因此需要 **2 片**。
* **总计**：$2 + 1 + 2 = 5$ 片。

## **2. 译码选择方案优缺点简述 (4分)**

* **全译码法**：
  * **优点**：地址空间唯一，无重叠地址，便于存储器容量扩展。
  * **缺点**：译码电路设计相对复杂，需要更多的逻辑门或译码器芯片。
* **部分译码法**：
  * **优点**：比全译码法简单，能节省硬件成本。
  * **缺点**：会导致地址重叠（一个单元对应多个地址），浪费地址空间。
* **线选法**：
  * **优点**：电路极其简单，不需要译码器。
  * **缺点**：地址空间严重不连续，且极易导致地址冲突，不适合本题的大容量连续设计。

## **3. CPU 与存储器连线（采用 2:4 译码器） (6分)**

* **地址线分配**：$A_{12}, A_{11}$ 接入 2:4 译码器输入端。
* **片选逻辑设计**：
  * **ROM (0000H-07FFH)**：由译码器输出 $Y_0$ 选通，两片 ROM 并联连接数据线 $D_0 \sim D_3$ 和 $D_4 \sim D_7$。
  * **1K RAM (0800H-0FFFH)**：由译码器输出 $Y_1$ 结合 $A_{10}$ 进行字选。当 $A_{10}=0$ 选第一片，当 $A_{10}=1$ 选第二片。
  * **4K RAM (1000H-1FFFH)**：由地址线 $A_{12}$ 直接选通（或组合译码器输出 $Y_2, Y_3$），对应最高 4K 地址空间。
* **控制信号**：$\text{MREQ}$ 信号连接译码器使能端，$R/\overline{W}$ 连接 RAM 的读写控制端。

## **4. 0B1FH 单元所在芯片的最小地址 (3分)**

* **地址解析**：$0B1FH$ 的二进制为 `0 1011 0001 1111`。
* **范围判断**：该地址的高位 $A_{12}A_{11}$ 为 `01`，且 $A_{10}$ 为 `0`，属于地址区间 $0800H \sim 0BFFH$。
* **结论**：该单元位于第一片 1K RAM 中，该芯片的起始地址（最小地址）为 **$0800H$**。
