# 2023期末试卷答案

[toc]

## 2023

1，2题代码如下：

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
          ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                
           MOV    AH,09H
           INT    21H

           ;填空③
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
           ;填空④
           ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                 
          ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           ;填空⑦
           LEA    DI,CITYTAB[BX]
           POP    BX
           ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           ;填空⑨
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                   
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-1程序填空题

以上程序中子程序GETL实现接受一个城市名输入，然后在数据段定义的城市名字符串列表中进行搜索，如找到则输出相应完整字符串，并获得序列号。该子程序及相关部分程序中有十处空白，已用①到⑩标出。请将空白处填入适当的指令，每空2分，每空限填一条指令。

（确定答案，已经调试能够正常运行）

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
           mov    es,ax                        ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           push BX                          ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                      ;输出'WHICH CITY?'
           MOV    AH,09H
           INT    21H

           lea    dx,CITYIN                    ;填空③,输入字符串
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
    ;这里开始比较了
           mov    cl,CITYIN[1]                 ;填空④，字符串长度
           lea    si,cityin[2]                 ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                        ;比较是否相等
           pop    di                           ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           shl    bx,cl                        ;填空⑦,bx*=32,字符串长度
           LEA    DI,CITYTAB[BX]
           POP    BX
           cmp    bx,9                         ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           add    CITYOUT+6,30h                ;填空⑨(前面pop过了，我感觉这里是add  CITYOUT+6,30h)
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           mov    cx, 16                       ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                 
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-2读程序题

1.❀处的标号START作用是什么？（2分）
START是程序的入口标号，标志程序从这里开始执行，并作为程序入口点被汇编器用在 END START 指令中，指定程序从此处开始运行。

2.GETT子程序的主要功能是什么？（请参看附录2）（2分）
GETT 子程序的功能是从 CMOS 实时时钟读取当前的时间（小时和分钟）。其中，高字节 AH 保存当前小时，低字节 AL 保存当前分钟。

3.请描述出IP指向甲、乙、丙、丁等四处时，堆栈段的使用情况，包括堆栈指针和相应存储单元的内容。（6分）

#### 甲
| 堆栈   |
| ---- |
|      |
|      |
| 0    |
| (ds) |

sp=0FFFCh

#### 乙
| 堆栈   |
| ---- |
|      |
|  (IP)    |
| AX   |
| 0    |
| (ds) |

IP:call getl下一句的ip

sp=0FFF8h

#### 丙
| 堆栈   |
| ---- |
|  (BP)    |
|  (IP)    |
| BX   |
| AX   |
| 0    |
| (ds) |

IP:call now下一句的ip

sp=0FFF4h

#### 丁
| 堆栈   |
| ---- |
| BX   |
| AX   |
| 0    |
| (ds) |
sp=0FFF8h

4.△处的语句作用是什么？为什么此处要使用BP寄存器？（2分）
注意，上方答案已经更新。在CALL GETT之后，PUSH AX； 在调用CALL GETL之后，要PUSH BX而不是POP AX。因此现在栈里面，有两个数据，PUSH AX是把时钟数据放入栈中，PUSH BX是把时区信息放到栈中。在△处，[BP+6]获取的是时钟信息。上面的[BP+4]获取的是时区信息。 

使用 BP 的原因：
由于子程序执行时，SP 的值会随着入栈、出栈操作不断变化，而 BP 被固定用于指向当前栈帧，便于访问传入的参数和局部变量。

5.☆处的两个语句作用是什么？如果去掉会有什么影响？（2分）
作用：
PUSHF和POPF用于保存和恢复标志寄存器FLAGS的状态。
这两个指令确保在循环左移ROL和条件判断JNZ时，标志寄存器的原始状态不受破坏。
去掉的影响：
如果没有PUSHF和POPF，标志寄存器的状态可能在子程序中被错误修改，导致循环条件或程序逻辑出错。

6.NOW子程序的主要功能是什么？（2分）  
根据输入的时间信息和城市时区差异，计算并显示当前的城市时间（以 "HH:MM" 格式输出）。

关于NOW的逻辑的解释：为什么△附近的代码，要先加24,还要减24,还有一个减8？ **答：** 这里，获取到的小时是使用BCD码的，```MOV AL,DH```的指令，把BCD编码的小时存入AL。注意在MS DOS和Microsoft Windows中，主板的CMOS存储的时间是本地时间。**此题目默认电脑在中国，CMOS中存储的是北京时间。**北京时间是UTC+8,所以要先减8。CITYAB中，每一行的时区依次加1。也就是LONDON是UTC+0, BERLIN是UTC+1 ... BEIJING是UTC+8。所以要先减8再加上时区。先加24再减24的目的是，防止减8之后变成负数。

7.丁处指令的功能是什么？（2分）

（书P207,ret的本质是pop sp,此处ret 4是在pop ip的基础上再pop sp+2,pop sp+4)

```RET 4```指令用于从子程序返回，同时清理调用时传入的 4 字节参数。（这四个字节的参数是，```CALL GETT```之后的```PUSH AX```，和```CALL GETL```后的```PUSH BX```）调用者堆栈的指针自动调整，避免手动释放参数。

8.此程序的完整功能是什么?请简要描述,并用合适的自拟输入内容演示程序行后可能输出的典型结果(GETT子程序功能请参看附录)(2分)

程序功能：
该程序提示用户输入一个城市名称，查找对应城市的时区信息，根据当前时间（由 CMOS 提供）计算并显示城市的本地时间。如果输入的城市未找到，则输出默认消息 "I DO NOT KNOW :("。

典型结果：
输入：BEIJING
输出：UMT+8 BEIJING, CHINA 13:45

## 2023-3编程计算题

请编写程序段，实现运算（A*B+2024）/C+D*E，其中A、B、C、D、E均为有符号数字型变量名。程序必须考虑运算导致的字长改变（余数不计），并请说明你的最终运算结果字长。

```asm
datarea segment
        a       dw 506
        b       dw 4
        cc      dw 2          ;在真实的汇编语言编程中，c是一个关键字，会报错。但是考试还得怎么写
        d       dw 3
        e       dw 4
        ;这里的实例答案应该是07f4h
datarea ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea
        start:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                mov    ds,ax
            
        ;(A*B+2024)/C+D*E
        ;考试从这儿开始写
                mov    ax,a
                mov    bx,b
                imul   bx                           ;(dx:ax)=ax*bx=a*b
                add    ax,2024                      ;(dx:ax)=a*b+2024
                adc    dx,0
                mov    bx,cc
                idiv   bx                           ;(dx:ax)/bx=ax...dx
                mov    bx,ax
                mov    ax,d
                mov    cx,e
                imul   cx                           ;(dx:ax)=ax*cx=d*e
                add    ax,bx
                adc    dx,0
        ;结果存在(dx:ax)里
        ;考试从这儿结束
                ret
main endp
prognam ends
end start
```

## 2023-4编程循环题

请编写完整程序实现新同学插入原班级名单并显示的功能。设班级名单为N个单元的数组，每个单元有10个字节。其中第一个字节存放着学号，其余9个字节存放学生英文姓名。假定起始时名单中已有n个同学，学号已按照姓名字母为序升序排列，现再从键盘接收一个姓名的输入，并插入已有名单。

```asm
datarea segment
    arr     db 1,'daniel   '
            db 2,'joana    '
            db 3,'misaka   '
            db 4,'xxw      '
            db 5,'zeyuwang '
            db 10 dup(?)
    n       db 5
    buf     db 9,?,9 dup(' ')
datarea ends
prognam segment
main proc far
            assume cs:prognam,ds:datarea,es:datarea
    start:  
            push   ds
            sub    ax,ax
            push   ax
            mov    ax,datarea
            mov    ds,ax
            mov    es,ax

    ;输入新的姓名
            lea    dx,buf
            mov    ah,0ah
            int    21h
            call   crlf

            mov    bx,1
            sub    dx,dx
    search: 
            lea    di,buf[2]
            lea    si,arr[bx]
            mov    cl,buf[1]
            cld;我记得cld只能拓展ax,就算扩展al也是cbw(没有在扩展啊？这不是在设置方向位？)
            repe   cmpsb
            jge    find
            inc    dl;用之前是不是没有初始化（）上面sub dx,dx
            add    bx,10
            cmp    dl,n
            jge    find
            jmp    search
            
    ;找到了,插入排序。dh放当前索引，bx放实际偏移地址
    find:   
            mov    al,n
            mov    dh,10
            mul    dh                                  ;ax=10*n
            mov    bx,ax
            mov    dh,n
    ;后边数都往后挪，腾出一个空位，把输入的信息插入
    sort:   
            cmp    dh,dl
            jle    insert
            push   dx
            lea    si,arr[bx-10]
            lea    di,arr[bx]
            mov    cl,10
            cld
            rep    movsb
            inc    arr[bx]
            pop    dx
            sub    bx,10
            dec    dh
            jmp    sort
    insert: 
    ;用空格先填充
            lea    di, arr[bx+1]
            mov    al, ' '
            mov    cx, 9
            cld
            rep    stosb
    ;填入新的索引
            mov    arr[bx],dh
            inc    arr[bx]
    ;将名字插入
            lea    si,buf[2]
            lea    di,arr[bx+1]
            mov    cl,buf[1]
            cld
            rep    movsb
            inc    n                                   ;总数加1
            call   output
            ret
main endp
output proc
            sub    bx,bx
            sub    cl,cl
    o1:     
            mov    si,1
            mov    dl,arr[bx]                          ;懒了，按一位数算
            add    dl,30h
            mov    ah,2
            int    21h
            mov    dl,' '
            mov    ah,2
            int    21h
    o2:     
            mov    dl,arr[bx+si]
            mov    ah,2
            int    21h
            inc    si
            cmp    si,10
            jl     o2
            call   crlf
            inc    cl
            add    bx,10
            cmp    cl,n
            jl     o1
            ret
output endp
crlf proc
            push   dx
            mov    dl,0dh
            mov    ah,02h
            int    21h
            mov    dl,0ah
            mov    ah,02h
            int    21h
            pop    dx
            ret
crlf endp
prognam ends
end start
```

dty(序号不对但是不会改了qwq)
```
data segment
    arr     db 1,'daniel   '
            db 2,'joana    '
            db 3,'misaka   '
            db 4,'xxw      '
    cur   db 5,'zeyuwang '
            db 10 dup(?)
    n       db 5
    namelabel label byte
    max db 10
    act db ?
    buf db 10 dup(?)

data ends
code segment
main proc far
assume cs:code,ds:data,es:data
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax
    mov es,ax
    lea dx,namelabel
    mov ah,0ah
    int 21h

    lea si,cur
    lea di,buf
    inc si
outloop:
    push si
    mov cx,10d
    cld
    repe cmpsb
    pop si
    jle found
    
movcur:
    push si
    mov di,si
    add di,10
    mov cx,10d
    cld
    rep movsb
    pop si
    sub si,10d
    cmp si,0
    lea di,buf
    jge outloop
found:
    mov di,si
    add di,10d
    lea si,buf
    mov cx,10d
    sub si,2
    mov [si],al
    rep movsb

    

    ret
main endp
code ends
end start
```

## 2023-5编程中断题

请完整程序采用接管1CH中断的方法实现在一小时倒计时的功能。程序开始时从59分59秒开始倒计时，每秒刷新一次时间。当计时回到00:00时重新从59:59开始倒计时。

```asm
datarea segment
    min     db 59
    sec     db 59
    count   db 1     ;18次中断大概是1秒，设成count=1保证
datarea ends
prognam segment
main proc far
              assume cs:prognam,ds:datarea,es:datarea
    start:    
              push   ds
              sub    ax,ax
              push   ax
              mov    ax,datarea
              mov    ds,ax
              mov    es,ax
    ;取中断向量
              mov    al,1ch
              mov    ah,35h
              int    21h
              push   es
              push   bx
    ;设置中断向量
              push   ds
              mov    ax,seg countdown
              mov    ds,ax
              mov    dx,offset countdown
              mov    al,1ch
              mov    ah,25h
              int    21h
              pop    ds
    ;打开定时器
              in     al,21h
              and    al,0feh                             ;11111110b
              out    21h,al
              sti
    ;要无限循环
    loops:    jmp    loops
    ;恢复中断向量
              pop    dx
              pop    ds
              mov    al,1ch
              mov    ah,25h
              int    21h
              ret
main endp
countdown proc
              push   ds
              push   ax
              push   cx
              push   dx

              mov    ax,datarea
              mov    ds,ax
              sti

              dec    count
              jnz    exit
              mov    count,18
              call   output
              cmp    sec,0
              jne    sdec
              mov    sec,60
              cmp    min,0
              jne    mdec
              mov    min,60
    mdec:     dec    min
    sdec:     dec    sec

    exit:     
              pop    dx
              pop    cx
              pop    ax
              pop    ds
              iret
countdown endp
output proc
              mov    al,min
              call   putnum
              mov    dl,':'
              call   putchar
              mov    al,sec
              call   putnum
              mov    dl,0dh
              call   putchar
              ret
output endp
putnum proc
              cbw
              mov    bl,10
              div    bl
              push   ax
              mov    dl,al
              add    dl,'0'
              call   putchar
              pop    ax
              mov    dl,ah
              add    dl,'0'
              call   putchar
              ret
putnum endp
putchar proc
              mov    ah,2
              int    21h
              ret
putchar endp
prognam ends
end start
```

dty:
```

data segment
    count dw 1
    hour dw 59d
    minute dw 59d
data ends
code segment
main proc far
assume cs:code,ds:data,es:data
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax
    mov es,ax
    mov al,1ch
    mov ah,35h
    int 21h
    push es
    push bx
    push ds

    mov dx,offset cal
    mov ax,seg cal
    mov ds,ax
    mov al,1ch
    mov ah,25h
    int 21h
    pop ds

    sti

    mov di,20000
dec1:
    mov si,30000
dec2:
    dec si
    jnz dec2
    dec di
    jnz dec1

    pop dx
    pop ds
    mov al,1ch
    mov ah,25h
    int 21h
    ret

main endp
cal proc near
    push dx
    push bx
    push cx
    push ax

    dec count
    jnz exit

    sti

    ; mov ah,02h
    ; mov bh,00h
    ; mov dh,00h
    ; mov dl,00h
    ; int 10h

    mov bx,hour
    call display
    mov dl,':'
    mov ah,02h
    int 21h
    mov bx,minute
    call display
    mov bx,minute
    cmp bx,0
    jz jiewei
    dec minute
    jmp exit2
jiewei:
    mov bx,hour
    cmp bx,0
    jz newbegin
    dec hour
    mov bx,59d
    mov minute,bx
    jmp exit2
newbegin:
    mov bx,59d
    mov hour,bx
    mov minute,bx  

exit2:
    mov count,18d
exit:
    cli
    pop ax
    pop cx
    pop bx
    pop dx
    iret
cal endp
display proc near
    mov cx,10d
    call dec_div
    mov cx,1d
    call dec_div
    ret
display endp
dec_div proc near
    mov ax,bx
    mov dx,0
    div cx
    mov bx,dx
    mov dl,al
    mov ah,02h
    add dl,30h
    int 21h
    ret
dec_div endp
code ends
end start
```

wn

```asm
dseg	segment
	count	dw	1
	hour	dw	59
	min		dw	60
dseg	ends
cseg	segment
	assume	cs:cseg,ds:dseg,es:dseg
main	proc	far
start:
	push	ds
	sub		ax,ax
	push	ax

	mov		ax,dseg
	mov		ds,ax
	mov		es,ax
begin:
	mov		al,1ch
	mov		ah,35h
	int		21h
	push	es
	push	bx

	push	ds
	mov		ax,seg	ring
	mov		ds,ax
	mov		dx,offset	ring
	mov		al,1ch
	mov		ah,25h
	int		21h
	pop		ds

	in		al,21h
	and		al,11111110b
	out		21h,al
	sti

	mov		si,3000h
loop1:
	mov		di,3000h
loop2:
	dec		di
	jnz		loop2
	dec		si
	jnz		loop1

	pop		dx
	pop		ds
	mov		al,1ch
	mov		ah,25h
	int		21h

	ret
main	endp
ring	proc	near
	push	ds
	mov		ax,dseg
	mov		ds,ax

	dec		count
	jnz		exit
	dec		min
	cmp		min,0
	jge		print
	mov		ax,59
	mov		min,ax
	dec		hour
	cmp		hour,0
	jge		print
	mov		ax,59
	mov		min,ax
	mov		hour,ax
print:
	mov		bx,hour
	mov		cx,10
	call	disp
	mov		cx,1
	call	disp

	mov		dl,':'
	mov		ah,02h
	int		21h

	mov		bx,min
	mov		cx,10
	call	disp
	mov		cx,1
	call	disp

	mov		dl,10
	mov		ah,02h
	int		21h

	mov		dl,13
	mov		ah,02h
	int		21h

	mov		ax,18
	mov		count,ax
exit:
	cli
	pop		ds
	iret
ring	endp
disp	proc	near
	mov		ax,bx
	mov		dx,0
	idiv	cx
	mov		bx,dx
	mov		dl,al
	add		dl,30h
	mov		ah,02h
	int		21h
	ret
disp	endp
cseg	ends
	end		start
```

## 2023附录

附录1：DOS系统功能调用（INT 21H）

| AH  | 功能             | 调用参数                                       | 返回参数                  |
| --- | ---------------- | ---------------------------------------------- | ------------------------- |
| 01  | 键盘输入并回显   |                                                | AL=输入的字符             |
| 02  | 显示输出         | DL=输出字符                                    |                           |
| 09  | 显示字符串       | DS：DX=串地址，串以'$'结束                     |                           |
| 0A  | 键盘输入到缓冲区 | DS：DX=缓冲区首址<br>(DS：DX)=缓冲区最大字符数 | (DS：DX)=实际输入的字符数 |
| 25  | 设置中断向量     | DS：DX=中断向量<br>AL=中断类型号               |                           |
| 35  | 取中断向量       | AL=中断类型号                                  | ES：BX=中断向量           |

1CH中断每秒钟约产生18次

附录2：CMOS RAM 中的时间信息

| 单元 | 存放内容 |
| ---- | -------- |
| 0    | 秒       |
| 2    | 分       |
| 4    | 时       |
| 7    | 日       |
| 8    | 月       |
| 9    | 年       |

这些数据以BCD码的方式存放。

从CMOS RAM 中读取信息的方式是：

```
OUT 70H, XX ; XX 为要访问的单元地址
IN AL, 71H   ; 从单元处读取数据
```
