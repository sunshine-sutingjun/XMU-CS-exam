# 2021期末试卷答案

## 一、

<details>
<summary>题目代码</summary>

```asm
.MODEL TINY ;注意：MODEL TINY编译错误，因为TINY不允许@data操作。改成MODEL LARGE就可以正常运行了。不必完全重写。
.STACK 100H
.DATA
STR1 DB 'tvrannosaurus',0DH,0AH,'$' ;①
LEN DW $-STR1 ;②
MESS1 DB 'PLEASE INPUT A NUMBER BETWEEN 0 TO 9: ',24H
STR2 DB 13, 10, 20 DUP (?), 0DH, 0AH, 'CAN YOU RICOGNIZE IT?', 24H
TABLE DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
.CODE
START:
    MOV AX,@DATA
    MOV DS,AX
    LEA BX,TABLE
    MOV CX, LEN
    LEA DX,STR1
    MOV AH, 09H
    INT 21H
    LEA DX, MESS1
    MOV AH, 09H
    INT 21H
    MOV AH, 01H
    INT 21H
    SUB AL,30H
    JB EXIT
    CMP AL, 9
    JA EXIT
    PUSH AX
    CALL CHANGE
    LEA DX, STR2 ;③
    MOV AH, 09H ;④
    INT 21H
EXIT:
    MOV AX,4C00H
    INT 21H
CHANGE PROC NEAR
    PUSH BP
    MOV BP, SP
    PUSH SI
    PUSH DX
    PUSH AX
    MOV SI, 0
    MOV DX,[BP+4]; ⑥
    MOV BP, 2
C1: MOV AL, STR1[SI]
    SUB AL, 60H
    JC C3
    ADD AL,DL
    CMP AL, 26
    JNA C2
    SUB AL, 26
C2: XLAT
    MOV DS:STR2[BP][SI],AL
C3: INC SI
LOOP C1
POP AX
POP DX
POP SI
POP BP
RET 2 ;⑦
CHANGE ENDP
END START
```

</details>

1. ①②两处都出现了```$```符号，请问它们的作用是什么?(4分)
    ①:字符串结束符，调用ah=09h的int 21h中断的功能时，待显示的字符串以```'$'```结尾
    ②：地址计数器，在伪操作时表示当前内存的地址。```LEN DW S-STR1```中的```$```代表当前地址，即 LEN 的位置，STR1是字符串的起始地址，```$-STR1```计算的是字符串的长度。
2. 请描述出IP指向③④⑤⑥处时堆栈段的使用情况，包括堆栈指针和相应存储单元的内容。(6分)

    | ③    |
    | ---- |
    |      |
    |      |
    |      |
    |      |
    |      |
    | (ax) |

    | ④    |
    | ---- |
    |      |
    |      |
    |      |
    |      |
    |      |
    | (ax) |

    | ⑤    |
    | ---- |
    |      |
    |      |
    |      |
    |      |
    | (ip) |
    | (ax) |

    | ⑥    |
    | ---- |
    |      |
    | (ax) |
    | (dx) |
    | (si) |
    | (bp) |
    | (ip) |
    | (ax) |

3. ⑦是真指令么？它的功能是什么？(3分)
    不是。告诉汇编器程序从```START```标签开始执行。在某些汇编器中，```END```指令用于标记程序的结束，并且可以指定程序的入口点。

    伪指令，标记子程序结束

4. 此程序的完整功能是什么？请简要描述。(4分)
    提示输入一个0到9之间的数字n，将字符串STR1中的每个字符根据用户输入的数字按字母表顺序循环右移(n+1)位，由小写转化为大写后，存储在STR2中。
5. 如果程序运行最初输入‘2’，请写出程序运行的完整结果（含格式）。(3分)

    ```plaintext
    tvrannosaurus
    PLEASE INPUT A NUMBER BETWEEN 0 TO 9:2
    WYUDQQRVDXUXV
    CAN YOU RICOGNIZE IT?
    ```

<details>
<summary>代码理解和注释</summary>

```asm
datarea segment
        STR1    DB 'tvrannosaurus',0DH,0AH,'$'                                       ;①
        LEN     DW $-STR1                                                            ;②
        MESS1   DB 'PLEASE INPUT A NUMBER BETWEEN 0 TO 9: ',24H
        STR2    DB 13, 10, 20 DUP (?), 0DH, 0AH, 'CAN YOU RICOGNIZE IT?', 24H
        TABLE   DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
datarea ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea
        START:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                MOV    DS,AX
        ;bx=大写字母表的首地址，cx=str1的长度
                LEA    BX,TABLE
                MOV    CX, LEN
        ;输出'tvrannosaurus'
                LEA    DX,STR1
                MOV    AH, 09H
                INT    21H
        ;输出'PLEASE INPUT A NUMBER BETWEEN 0 TO 9: '
                LEA    DX, MESS1
                MOV    AH, 09H
                INT    21H
        ;输入0~9的数字
                MOV    AH, 01H
                INT    21H
        ;字符-'0'变为纯数字
                SUB    AL,30H
                JB     EXIT                         ;al<0
                CMP    AL, 9
                JA     EXIT                         ;al>9
                PUSH   AX
                CALL   CHANGE
        ;输出'CAN YOU RICOGNIZE IT?'
                LEA    DX, STR2                     ;③
                MOV    AH, 09H                      ;④
                INT    21H
        EXIT:   
                MOV    AX,4C00H
                INT    21H
main endp
CHANGE PROC NEAR
                PUSH   BP
                MOV    BP, SP
                PUSH   SI
                PUSH   DX
                PUSH   AX

                MOV    SI, 0
                MOV    DX,[BP+4]                    ;⑥，dx=dx
                MOV    BP, 2                        ;上移一位？
        C1:     MOV    AL, STR1[SI]                 ;'tvrannosaurus'
                SUB    AL, 60H                      ;60h='a'-1,求是小写字母表的第几位
                JC     C3                           ;减法导致借位
                ADD    AL,DL
                CMP    AL, 26                       ;26='z'-'a'+1
                JNA    C2                           ;al<='z'-'a'+1
                SUB    AL, 26
        C2:     XLAT                                ;al=[bx+al],映射到大写字母表
        ;注意，这个代码有逻辑错误。代码的意图是，如果输入数字是2,那么每个字母往后推3个。但是如果输入是2,字母x会推到TABLE的26下标，也就是越界。
                MOV    DS:STR2[BP][SI],AL
        C3:     INC    SI
                LOOP   C1
                POP    AX
                POP    DX
                POP    SI
                POP    BP
                RET    2                            ;⑦
CHANGE ENDP
prognam ends
END START
```

相当于

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    char s[] = "tvrannosaurus";
    int n;
    cin>>n;
    for (int i = 0; i < strlen(s); i++)
    {
        s[i] += (n+1);
        if (s[i] > 'z')
            s[i] -= 26;
        s[i]=s[i]-'a'+'A';
    }
    cout<<s<<endl;
    return 0;
}
```

</details>

## 二、

<details>
<summary>空白题干</summary>

```asm
data segment
    test1 db 'The food monkeys like: $banana'
    test2 db 'The food pandas like : $bamboo'
    test3 db 'The food magpies like: $cherry'
    ans   db 7, ?, 7 dup(?)
    wro   db 0dh, 0ah, 'Wrong!', 0dh, 0ah, 24h
    rgh   db 0dh, 0ah, 'Right!', 0dh, 0ah, 24h
data ends

code segment
main proc far
            assume cs:code, ds:data, es:data
      ;①
            push   ds
            sub    ax, ax
            push   ax
            mov    ax, data
            mov    ds, ax
      ;②

            mov    cx, 3
            lea    dx, test1
      exm:  mov    ah, 09h
            int    21h
      ;③
            mov    si, dx
            lea    dx, ans
            mov    ah, 0ah
            int    21h
      ; ④
            mov    cx, 6
      ; ⑤
      ; ⑥
      ; ⑦
            repnz  cmpsb
            jnz    wrong
            lea    dx, rgh
            mov    ah, 09h
            int    21h
      ; ⑧
      wrong:lea    dx, wro
            mov    ah, 09h
            int    21h
      next: 
      ; ⑨
      ; ⑩
            add    dx, 30
            loop   exm
            ret
main endp
code ends
    end start
```

以上程序实现三次提问并等待输入答案，根据输入与标准答案是否相符给出判断。程序中有十处空白，请将空白处填入适当的指令，每空2分，限填一条指令。
</details>

可运行成功的参考答案

```asm
data segment
    test1 db 'The food monkeys like: $banana'
    test2 db 'The food pandas like : $bamboo'
    test3 db 'The food magpies like: $cherry'
    ans   db 7, ?, 7 dup(?)
    wro   db 0dh, 0ah, 'Wrong!', 0dh, 0ah, 24h
    rgh   db 0dh, 0ah, 'Right!', 0dh, 0ah, 24h
data ends

code segment
main proc far
          assume cs:code, ds:data, es:data
    start:                                    ;①开始标签
          push   ds
          sub    ax, ax
          push   ax
          mov    ax, data
          mov    ds, ax
          mov    es,ax                        ;②

    ;输入和比较的次数
          mov    cx, 3
    ;输出提示
          lea    dx, test1
    exm:  mov    ah, 09h
          int    21h
          push   dx                           ;③,记录当前字符串首地址
          mov    si, dx
    ;输入食物
          lea    dx, ans
          mov    ah, 0ah
          int    21h

          push   cx                           ; ④,存loop计数器
          mov    cx, 6                        ;比较最后六个字符
          add    si, 24                       ; ⑤,si指针从提示字符串移动到答案字符串，要加24。
                                              ; 注意每个'$'前面其实有个空格。根据后文add    dx, 30 推出, 每个字符串长度为30
          lea    di,ans[2]                    ; ⑥,比较答案是否相同
          cld                                 ; ⑦
          repnz  cmpsb
          jnz    wrong                        ;错
          lea    dx, rgh
          mov    ah, 09h
          int    21h
          jmp    next                         ; ⑧，对了就不要输出错
    wrong:lea    dx, wro
          mov    ah, 09h
          int    21h
    next: 
          pop    cx                           ; ⑨,恢复计数器
          pop    dx                           ; ⑩，恢复字符串首地址
          add    dx, 30                       ;下一个字符串
          loop   exm
          ret
main endp
code ends
end start
```

## 三、

### 3.1

请编写程序段，实现运算A/2022+B*C+D*2，其中ABCD均为有符号数字型变量（字数据）名。最终运算结果保存下来需要多大的存储空间？ (20分)

#### 3.1.1 joana's code

```asm
mov ax,a
cwd
mov cx,2022
idiv cx;除完只剩ax

cwd
mov cx,ax
mov bx,dx

mov ax,b
imul c;存储在dx,ax中
add cx,ax
adc bx,dx ;这里不对吧？前面在bx里存了余数，直接丢弃就可以。这里却又加起来了。应该是adc dx,0?
mov ax,d
mov si,2
imul si
add cx,ax
adc bx,0

```

存储在cx,bx中

#### 3.1.2 Misaka-xxw's code

```asm
mov ax,a
cwd        ;(dx,ax)=A
mov bx,2022
idiv bx    ;(dx,ax)/2022=ax...dx,dx舍弃
mov bx,ax  ;bx=(A/2022)
mov ax,b   ;ax=B
cwd        ;(dx,ax)=B
imul c     ;(dx,ax)=B*C
mov cx,dx  ;(cx,ax)=B*C
add bx,ax  ;(cx,bx)=bx+ax=(A/2022)+B*C
adc cx,0   ;进位
mov ax,2
imul d     ;(dx,ax)=D*2
add bx,ax
adc cx,dx
```

结果是双字，存在cx,bx里

### 3.2

请编写完整程序找出不超过100 的质数，并以“个位是1的:”“个位是2
的:”....“个位是9的:”方式分组显示出来。(20分)

#### 3.2.1 joana's code

```asm
data segment
    tablenum db 10 dup(20 dup(?))
    tablepos db 10 dup(?)
    mess1 db '个位是1的：'
    mess2 db '个位是2的：'
    mess3 db '个位是3的：'
data ends
code segment
main proc far
assume cs:code,ds:data
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax

    mov ax,1
    mov cx,100
    push cx
outloop:
    call isprime
    cmp dx,1
    jnz nextloop
    mov bx,1
    push ax
    div bx
    ;ax储存个位数
    dec ax
    lea bx,tablepos
    mov di,ax
    add di,bx
    mov si,[di]
    mov bx,20
    mul bx
    add si,ax
    pop ax
    mov [si],ax
    inc si
    mov [di],si
nextloop:
    inc ax
    pop cx
    loop outloop

    mov si,0
    mov cx,10
    push cx
    mov di,0
    lea dx,mess1
    mov ah,09h
output:
    int 21h
    lea bx,tablepos
    mov cx,[ bx+di]

    push si
    push di

    outputloop:
    mov bx,[si]
    call dec_oct
    inc si
    loop outputloop

    pop di
    pop si
    pop cx
    add si,20
    add di,6
    loop output
    ret
main endp
dec_oct proc near
    push cx
    push bx
    mov cx,10d
    call divdec
    mov cx,1d
    call divdec
    pop bx
    pop cx
    ret
dec_oct endp
divdec proc near
    div cx
    mov bx,dx
    mov dl,al
    add dl,30h
    mov ah,02h
    int 21h
    ret
divdec endp
isprime proc near
loopprime:
    mov bx,2
    push ax
    div bx
    pop ax
    test dx,dx
    jz notprime
next:
    inc bx
    cmp bx,ax
    jl loopprime
    mov dx,1
    jmp exit
notprime:
    mov dx,0
exit:
    ret
isprime endp
code ends
end start
```

#### 3.2.2 Misaka-xxw's code

```asm
datarea segment
    ;想了一下，不想用数组存
    ; prime   db 10 dup(0,10 dup(?))                   ;个位数为n的个数，和最多十个质数
    ; msg     db '个位数是',?,'的','$'       ;实际中文必乱码
    msg     db 'prime number end with ',?,' :','$'    ;实际中文必乱码
    crlfstr db 0dh,0ah,'$'
datarea ends
prognam segment
main proc far
            assume cs:prognam,ds:datarea,es:datarea
    start:  
            push   ds
            sub    ax,ax
            push   ax
            mov    ax,datarea
            mov    ds,ax
            mov    es,ax
            mov    bh,1                                ;十位数，防止从0开始
            mov    bl,0                                ;个位数
    gewei:                                             ;个位循环
    ;提示信息里的数字
            mov    dl,bl
            add    dl,30h
            mov    si,22
            mov    msg[si],dl
    ;输出提示信息
            lea    dx,msg
            mov    ah,09h
            int    21h
    shiwei:                                            ;十位循环
            mov    al,10
            mul    bh                                  ;ax=bh*10
            add    al,bl                               ;al是一个小于100的数，bh*10+bl
            cmp    al,1                                ;1不是质数
            je     next
            mov    cl,2
            xor    ah,ah
    check:  
            cmp    cl,al
            jge    prime                               ;cl>=al
            push   ax
            div    cl                                  ;ax/cl=al...ah
            cmp    ah,0
            pop    ax
            jz     next
            inc    cl
            jmp    check
    prime:                                             ;是质数
            cmp    bh,0
            jz     zero
            mov    dl,bh
            add    dl,30h
            mov    ah,02h
            int    21h
    zero:                                              ;十位数为0
            mov    dl,bl
            add    dl,30h
            mov    ah,02h
            int    21h

            mov    dl,' '
            mov    ah,02h
            int    21h

    next:   
            inc    bh
            cmp    bh,10
            jl     shiwei                              ;十位数继续+1循环

            call   crlf
            mov    bh,0
            inc    bl
            cmp    bl,10
            jl     gewei
            
            ret
main endp
crlf proc
            lea    dx,crlfstr
            mov    ah,09h
            int    21h
            ret
crlf endp
prognam ends
end start
```

### 3.3

通过接管1CH号中断的方式实现等待10秒问询一次“Areyouready?”，如果输入'N'则等待10秒后再次询间，如果输入'Y'则以1秒为间隔依次显示“3”，“2”，“1”，“Go!” (20分)

#### 3.3.1 wn's code

```asm
dseg	segment
	count	dw	1
	count2	dw	1
	flag	dw	0

	mess0	db	'Are you ready?',10,13,'$'
	mess1	db	'1',10,13,'$'
	mess2	db	'2',10,13,'$'
	mess3	db	'3',10,13,'$'
	mess4	db	'Go!',10,13,'$'
	mess5	db	'must be N/Y',10,13,'$'
dseg	ends
cseg	segment
	assume cs:cseg,ds:dseg,es:dseg
main	proc	far
start:
	push	ds
	sub		ax,ax
	push	ax

	mov		ax,dseg
	mov		ds,ax
	mov		es,ax
begin:
	mov		al,1ch
	mov		ah,35h
	int		21h
	push	es
	push	bx

	push	ds
	mov		ax,seg ring
	mov		ds,ax
	mov		dx,offset ring
	mov		al,1ch
	mov		ah,25h
	int		21h
	pop		ds

	in		al,21h
	mov		al,11111100b
	out		21h,al

	sti

	mov		si,2000h
loop1:
	mov		di,3000h
loop2:
	dec		di
	jnz		loop2
	dec		si
	jnz		loop1

	pop		dx
	pop		ds
	mov		al,1ch
	mov		ah,25h
	int		21h

	ret
main	endp
ring	proc	near
	push	ds
	mov		ax,dseg
	mov		ds,ax

	sti
	in		al,20h
	or		al,20h
	out		20h,al

	cmp		flag,0
	jnz		next3

	dec		count
	jz		next22
	jmp		exit
next22:
	lea		dx,mess0
	mov		ah,09h
	int		21h
next0:
	mov		ah,01h
	int		21h

	cmp		al,'N'
	jnz		next1
	jmp		exit11
next1:
	cmp		al,'Y'
	jz		next2
	lea		dx,mess5
	mov		ah,09h
	int		21h
	jmp		next0
next2:
	mov		ax,3
	mov		flag,ax
	jmp		exit
next3:
	dec		count2
	jnz		exit

	cmp		flag,3
	jnz		next4
	lea		dx,mess3
	mov		ah,09h
	int		21h

	mov		ax,18
	mov		count2,ax

	mov		ax,2
	mov		flag,ax

	jmp		exit
next4:
	cmp		flag,2
	jnz		next5

	lea		dx,mess2
	mov		ah,09h
	int		21h

	mov		ax,18
	mov		count2,ax

	mov		ax,1
	mov		flag,ax

	jmp		exit
next5:
	cmp		flag,1
	jnz		next6

	lea		dx,mess1
	mov		ah,09h
	int		21h

	mov		ax,18
	mov		count2,ax

	mov		ax,4
	mov		flag,ax

	jmp		exit
next6:
	cmp		flag,4
	jnz		exit

	lea		dx,mess4
	mov		ah,09h
	int		21h

	mov		ax,18
	mov		count2,ax

	mov		ax,0
	mov		flag,ax

exit11:
	mov		ax,180
	mov		count,ax
exit:
	cli
	pop		ds
	iret
ring	endp
cseg	ends
	end		start
 ```

#### 3.3.2 Misaka-xxw's code

```asm
datarea segment
    msg1    db "Are you ready?",'$'
    msg2    db "3",0dh,0ah,'$'
            db "2",0dh,0ah,'$'
            db "1",0dh,0ah,'$'
            db "Go!",0dh,0ah,'$'
    count   db 1
    ready   db 0
    crlf    db 0dh,0ah,'$'
datarea ends
prognam segment
main proc far
              assume cs:prognam,ds:datarea,es:datarea
    start:    
              push   ds
              sub    ax,ax
              push   ax
              mov    ax,datarea
              mov    ds,ax
              mov    es,ax
    ;取中断向量
              mov    al,1ch
              mov    ah,35h
              int    21h
              push   es
              push   bx
    ;设置中断向量
              push   ds
              mov    ax,seg check
              mov    ds,ax
              mov    dx,offset check
              mov    al,1ch
              mov    ah,25h
              int    21h
              pop    ds
    ;打开定时器
              in     al,21h
              and    al,0feh
              out    21h,al
              sti
    ;死循环
    delay:    
              cmp    ready,0
              mov    ah,1
              int    21h
              push   ax
              lea    dx,crlf
              mov    ah,9
              int    21h
              pop    ax
              cmp    al,'Y'
              je     yes
              cmp    al,'y'
              jne    delay
    yes:      
              mov    count,1
              mov    ready,1
              mov    si,0
              jmp    delay
    ;重新设置原中断向量
              pop    dx
              pop    ds
              mov    al,1ch
              mov    ah,25h
              int    21h
              ret
main endp
check proc
              push   ds

              mov    ax,datarea
              mov    ds,ax
              sti

              dec    count
              jnz    exit

              cmp    ready,0
              jz     not_ready
    ;是否Go完了
              cmp    si,16
              jl     go
              mov    ready,0
              mov    count,1
              jmp    exit
    go:                                                  ;3,2,1,Go!
              mov    count,18                            ;1s
              lea    dx,msg2[si]
              mov    ah,9
              int    21h
              add    si,4
              jmp    exit
    not_ready:
              mov    count,180                           ;10s
              lea    dx,msg1
              mov    ah,9
              int    21h
    exit:     
              sti
              in     al,21h
              and    al,0feh
              out    21h,al
              pop    ds
              iret
check endp
prognam ends
end start
```
