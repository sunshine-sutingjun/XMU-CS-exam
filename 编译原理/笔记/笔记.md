# 编译原理
期中考试范围
第一章 1.1~1.5
第二章 2.1，2.2，2.4
第三章 都要
第四章 4.1~4.4，其中4.1.4（错误恢复策略）和4.4.5（预测分析中的错误恢复）不考
题型：作业题、大题

[TOC]
# 第一章 引论

# 第二章 一个简单的语法制导器
语法：描述某程序设计语言的正确形式
语义：定义程序的含义
## 上下文无关文法
四个元素

1. 终结符号集合/词法单元
2. 非终结符号集合/语法变量
3. 产生式集合，包括
   1. 被称为<i>产生式头/左部</i> 的非终结符号
   2. 箭头
   3. 被称为<i>产生式体/右部</i> 的，由终结符号和非终结符号组成的序列
4. 开始符号（要是非终结符号）

例：加减法表达式
```
list -> list+digit |list-digit |digit
digit-> 0|1|2|3|4|5|6|7|8|9
```
例：乘除法表达式
```
factor -> digit | ( expr ) 
term   -> term * factor 
        | term / factor 
        | factor 
expr   -> expr + term 
        | expr – term 
        | term
```

## 分析树和语法分析树
性质：
+ 根结点是开始符号Start Symbol 
+ 叶子结点是终结符或ε
+ 内部结点是一个非终结符 Non-Terminal 
+ 如果有产生式  $A \rightarrow x_1x_2…x_n$,  那么A是一个非终结符; 
$x_1x_2…x_n$ 是A 的孩子，是终结符或非终结符
一个文法生成的语言是它的某个分析树生成的串的集合。
为给定的符号串找到一棵分析树的过程称为串的语法分析(parsing)。
<!-- $\varepsilon$ -->

## 二义性
文法是否具有二义性？如果能构造出至少两棵不同的语法树，则文法是二义性的。构造一个左的和一个右的

## 下面的各个文法生成什么语言？
p31 ex2.2.2
常见答案：以x为变量，xx为二元操作符的x缀表达式的集合，注意都要加上<mark>集合</mark>二字

$$S\rightarrow aSbS|bSaS|\varepsilon$$

由相同数目的a和b组成的字符串的集合，或者空串

$$S\rightarrow a|S+S|SS|S*|(S)$$

以a为变量，包括+，连接，*和括号四种运算的表达
式的集合

## 语法制导方案与注释分析树
p37 ex2.3.1
构建一个语法制导翻译方案，该方案把算术表达式从**中缀**表示方式翻译成运算符在运算分量之前的**前缀**表示方式。例如，‐xy是表达式x‐y的前缀表示法。
给出输入9‐5+2和9‐5*2的注释分析树。

产生式
```
expr -> expr + term
      | expr - term
      | term
term -> term * factor
      | term / factor
      | factor
factor -> digit | (expr)
```
语法制导翻译方案
```
expr  -> {print("+")} expr + term
       | {print("-")} expr - term
       | term
term  -> {print("*")} term * factor
       | {print("/")} term / factor
       | factor
factor-> digit {print(digit)}
       | (expr)
```

9-5+2的注释分析树
![alt text](9-5+2.jpg)
## 递归下降语法分析器
为下列文法构造递归下降语法分析器。
(1)

$$S\rightarrow+ SS | ‐SS |a$$

```c
S()
{
    if(lookahead=='+'){
        match('+');S();S();
    }
    else if(lookahead=='-'){
        match('-');S();S();
    }
    else if(lookahead=='a'){
        match('a');
    }
    else error();
}
```

(3)

$$S\rightarrow 0S1|01$$

```c
S()
{
    if(lookahead=='0'){
        match('0');
        if(lookahead=='0'){//第一个字符还是0，说明还是调用S()
            S();match('1');
        }
        else if(lookahead=='1'){
            match('1');
        }
        else error();
    }
    else error();
}
```

# 第三章 词法分析
## 正则表达式
给出$\sum=\{0, 1\}$上的正则表达式

仅包含两个1
`0*10*10*`

不包含连续的0
`(1|01)*(ε|0)`

包含偶数个0
`(1*01*01*)*1*` 或者 `1*(1*01*01*)*1*`

## 正则表达式和状态转换图
P76 ex3.2.2 && P84 ex3.3.1

用自然语言表达该正则表达式的含义，画出状态转换图

注意点：1.xx的集合 2. 是否包括空串

1. `a(a|b)*a`以a开头和结尾且至少包含两个字符的a,b字符串的集合
2. `((ε|a)b*)*`由a和b组成的任意字符串的集合（包括ε）
3. `(a|b)*a(a|b)(a|b)`倒数第三个字符为a的任意的a,b字符串的集合
4. `a*ba*ba*ba`包含3个b的a,b字符串的集合
5. `(aa|bb)*((ab|ba)(aa|bb)*(ab|ba)(aa|bb)*)*`包含偶数个a和偶数个b的a,b字符串的集合

---

P76 ex3.2.5 && P93 ex3.5.1

列出下列语言的正则定义，设计DFA或者NFA
1. 包含5个元音的所有小写字母串，这些串中的元音按顺序出现。
2. 所有由按词典递增序排列的小写字母组成的串
3. 注释，即`/*`和`*/`之间的串，且串中没有不在双引号(`"`)中的`*/`
4. 所有由a和b组成且不含**子串**abb的串。
5. 所有由a和b组成且不含**子序列**abb的串。

3、
意思是，如果注释中中有`*/`，那必须括在双引号中，例如`/*注释里由/*和"*/"组成*/` 

答案：
```regex
\/\*([^"*]|\"[^"]*\"|(\*)+[^/*"]|(\*)+\"[^"]*\")*(\*)+\/
```

![alt text](image.png)

|表达式|匹配描述|例子|
|-|-|-|
|`c`|单个非运算符字符`c`|`a`|
|`\c`|字符`c`的字面值|`\*`|
|`"s"`|串`s`的字面值|`"**"`|
|`.`|除换行符以外的任何字符|`a.*b`|
|`^`ctrl+6|一行的开始|`^abc`|
|`$`|行的结尾|`abc$`|
|`[s]`|字符串`s`中的任何一个字符|`[abc]`|
|`[^s]`|不在字符串`s`中的任何一个字符|`[^abc]`|
|`r*`|和`r`匹配的零个或多个串连接成的串|`a*`|
|`r+`|和`r`匹配的一个或多个串连接成的串|`a+`|
|`r?`|零个或一个`r`|`a?`|
|`r{m,n}`|最少`m`个，最多`n`个`r`的重复出现|`a{1,5}`|
|`r1r2`|`r1`后加上`r2`|`ab`|
|`r1\|r2`|`r1`或`r2`|`a|b`|
|`(r)`|与`r`相同|`(a|b)`|
|`r1/r2`|后面跟有`r2`时的`r1`|`abc/123`|

4、5题都可以先画出“包含”的DFA状态图，然后反转非终态与终态，去掉死状态，就可以得到不包含的DFA状态图。所以可以先画图再推正则表达式。<mark>但是只有DFA能这样，NFA不可以，因为NFA没有唯一路径</mark>

## 有穷自动机：NFA和DFA

分为**不确定的有穷自动机（NFA）**和**确定的有穷自动机（DFA）**

**NFA**的组成：
1. 状态集合$S$
2. 输入符号集合$\sum$
3. 转移函数
4. 开始状态$s_0$
5. 接受(终止)状态集合：子集$F$

**状态表**：NFA的转移函数可用状态表表示。第一行是输入符号和$\varepsilon$，第一列是各个状态。

**DFA**是NFA的一个特例，DFA的性质
1. 没有输入$\varepsilon$上的转换
2. 对每个状态$s$和输入符号$a$，至多只有1条标记为$a$的边离开$s$

## 从NFA到DFA的子集构造法

首先由正则表达式构造出带有很多ε的NFA。
|操作|描述|
|-|-|
|ε-closure(s)|状态s通过ε到达的集合|
|ε-closure(T)|集合T中的状态s通过ε到达的集合|
|move(T,a)|集合T中的状态s通过a到达的集合|

<!-- 随便选代码块语言 -->

```csharp
一开始,  ε-closure(s0) 是 Dstates中的唯一状态，且它未加标记
while 在 Dstates 中有一个未标记状态:
     给 T加上标记
     foreach 输入符号a:
        U = ε-closure(move(T,a))
        if U 不在 Dstates 中:
            将U 加入到 Dstates且不加标记；
            Dtran[T,a] = U
```

# 第四章 语法分析
## 符号使用规定
终结符: 
_a_, _b_, _c_, _+_, _-_, punc, 0, 1,…, 9, Black strings: **id**, **if**
非终结符: 
A, B, C, S,  斜体串 _expr_
文法符号： X, Y, Z  表示非终结符或终结符号
终结符号串： u, v,…, z字母表中排在后面的小写字母
文法符号串：$\alpha$,$\beta$,$\gamma$

## 上下文无关文法
题型
(1) 给出这个串的一个最左推导。 
(2) 给出这个串的一个最右推导。 
(3) 给出这个串的一棵语法分析树。 
(4) 这个文法是否为二义性的？判断并说明你的回答。
(5) 描述这个文法生成的语言。

**二义性**：对于文法产生的每一个符号串，存在两棵不同的分析树（或两种不同的最左或最右推导）

P120 ex4.2.3
1. 所有由 0 和 1 组成的并且每个 0 之后都至少跟着一个 1 的串的集合。
   S → 1S | 01S | ε

2. 所有由 0 和 1 组成的回文的集合，也就是从前面和从后面读结果都相同的串的集合。
   S → 0S0 | 1S1 | 1 | 0 | ε

3. 所有由 0 和 1 组成的具有相同多个 0 和 1 的串的集合。
   S → 0S1S | 1S0S | ε

4. 所有由 0 和 1 组成的且 0 和 1 的个数不同的串的集合。
   S → A | B
   A → AA | EOE （A 是 0 比 1 多的串）
   B → BB | E1E （B 是 1 比 0 多的串）
   E → 0E1E | 1EOE | ε （E 是 0 和 1 的个数相等的串）

5. 所有由 0 和 1 组成的且其中不包含子串 011 的串的集合。
   S → A B
   A → 1 A | ε
   B → 0 B | 0 1 B | ε
   1*(0|01)*

6. 所有由 0 和 1 组成的形如 xy 的符号串，其中 x≠y，且 x、y 等长。
   S → AB | BA
   A → XAX | 0 （A 是奇数长度，中间为 0 的串）
   B → XBX | 1 （B 是奇数长度，中间为 1 的串）
   X → 0 | 1

## 左公因子与左递归

**左公因子**：箭头右边，竖线隔开的每段的公共前缀

提取左公因子：

$$
A\rightarrow \alpha\beta_1 |\alpha\beta_2 |...|\alpha\beta_n |\gamma\\
\Downarrow\\
A\rightarrow \alpha A'|\gamma\\
A'\rightarrow \beta_1 |\beta_2 |...|\beta_n
$$


消除左递归：

$$
A\rightarrow A\alpha | \beta\\
\Downarrow\\
A\rightarrow\beta A'\\
A'\rightarrow \alpha A'|\varepsilon
$$

P126 练习 4.3.1

下面是一个只包含符号 a 和 b 的正则表达式的文法。它使用 + 替代表示并运算的字符 “|”，以避免和文法中作为元符号使用的竖线相混淆：

$
rexpr\rightarrow rexpr+ rterm\mid rterm\\
rterm\rightarrow rterm~rfactor\mid rfactor\\
rfactor\rightarrow rfactor* \mid rprimary\\
rprimary\rightarrow a \mid b
$

(1) 对这个文法提取左公因子。
(2) 提取左公因子的变换能使这个文法适用于自顶向下的语法分析技术吗？
(3) 提取左公因子之后，从原文法中消除左递归。
(4) 得到的文法适用于自顶向下的语法分析吗？

答案：

(1) 文法无公共左因子，故不变；

(2) 不能：仍然存在左递归；

(3) 消除左递归：

$
rexpr\rightarrow rterm~rexpr'\\
rexpr'\rightarrow + rterm~rexpr'\mid \varepsilon \\
rterm\rightarrow rfactor~rterm'\\
rterm'\rightarrow * rfactor~rterm'\mid \varepsilon \\
rfactor\rightarrow rprimary~rfactor'\\
rfactor'\rightarrow * rfactor' \mid \varepsilon \\
rprimary\rightarrow a \mid b 
$

(4) 适用。文法中不存在左公因子，也不存在左递归。

## FIRST和FOLLOW

<!-- [白话版本](https://www.cnblogs.com/Fortunater/articles/12883910.html) -->

```python
# FIRST
E->?B
if ?=a: # E->aB
    FIRST(E)+=a
elif ?=A: # E->AB
    FIRST(E)+=FIRST(A)
    if A=>ε:
        FIRST(A)+=FIRST(B)
# FOLLOW
E->...A?...
if ?=b: # E->...Ab...
    FOLLOW(A)+=b
elif ?=B: # E->...AB...
    if nothing behind B:
        FOLLOW(B)+=FOLLOW(E)
        if B=>ε:
            FOLLOW(A)+=FOLLOW(E)
    FOLLOW(A)+=(FIRST(B)-ε)
```

<details>

**First集**是指从某个语法符号（非终结符或开始符号）推导出的串的首个终结符或空字符组成的集合。
**Follow集**则是指某个非终结符号后面可能紧跟的终结符集合。

First集的计算方法
1. 如果X是终结符或空字符ε，则First(X) = {X}。
2. 如果X是非终结符，并且存在产生式X → a...，其中a是终结符，则a属于First(X)。
3. 如果X是非终结符，并且存在产生式X → Y1Y2...Yk，其中Y1, Y2, ..., Yk是非终结符，那么需要将First(Y1)中除ε之外的所有元素加入First(X)。如果Y1可以推导出ε，则继续考虑Y2，以此类推，直到某个Yi不能推导出ε或者所有Yi都考虑完毕。如果所有Yi都可以推导出ε，则将ε也加入First(X)。

Follow集的计算方法
1. 如果S是开始符号，则将结束符号$加入Follow(S)。
2. 对于产生式A → αXβ，将First(β)中除ε之外的所有元素加入Follow(X)。如果β可以推导出ε（ε∈First(β)）或者β为空，则将Follow(A)加入Follow(X)。
3. 对于产生式A → αX，将Follow(A)加入Follow(X)。

示例

考虑以下文法G[E]：
```
E → TE'
E' → +TE' | ε
T → FT'
T' → *FT' | ε
F → (E) | i
```
对于这个文法，我们可以按照上述规则计算出First集和Follow集
```
First(E) = First(T) = First(F) = { (, i }
First(E') = { +, ε }
First(T') = { *, ε }

Follow(E) = { $, ) }
Follow(E') = { $, ) }
Follow(T) = { $, +, ) }
Follow(T') = { $, +, ) }
Follow(F) = { $, +, *, ) }
```

在计算过程中，我们需要反复迭代，直到First集和Follow集不再发生变化。

</details>

## 构造LL(1)分析表

预测分析表的构造
输入：文法G
输出：分析表M
方法： 
（1）对文法的每个产生式$A\rightarrow \alpha$ ，执行(2)和(3)。
（2）对FIRST($\alpha$)的每个终结符a，把$A\rightarrow \alpha$加入M[A, a]。
（3）如果 $\varepsilon$ 在FIRST($\alpha$)中，对FOLLOW(A)的每个终结符b（包括 $\$$ ），把 $A\rightarrow \alpha$ 加入M[A, b]。
（4）M的其它没有定义的条目都是error。

```python
for a in FIRST(α):
    M[A,a] += A→α
if ε in FIRST(α):
    for b in FOLLOW(A):
        M[A,b] += A→α
```
