# 2023期末试卷答案

[toc]

1，2题代码如下：

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
          ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                
           MOV    AH,09H
           INT    21H

           ;填空③
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
           ;填空④
           ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                 
          ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           ;填空⑦
           LEA    DI,CITYTAB[BX]
           POP    BX
           ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           ;填空⑨
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                   
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-1程序填空题

以上程序中子程序GETL实现接受一个城市名输入，然后在数据段定义的城市名字符串列表中进行搜索，如找到则输出相应完整字符串，并获得序列号。该子程序及相关部分程序中有十处空白，已用①到⑩标出。请将空白处填入适当的指令，每空2分，每空限填一条指令。

（确定答案，已经调试能够正常运行）

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
           mov    es,ax                        ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           pop    ax                           ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                      ;输出'WHICH CITY?'
           MOV    AH,09H
           INT    21H

           lea    dx,CITYIN                    ;填空③,输入字符串
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
    ;这里开始比较了
           mov    cl,CITYIN[1]                 ;填空④，字符串长度
           lea    si,cityin[2]                 ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                        ;比较是否相等
           pop    di                           ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           shl    bx,cl                        ;填空⑦,bx*=32,字符串长度
           LEA    DI,CITYTAB[BX]
           POP    BX
           cmp    bx,9                         ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           add    CITYOUT+6,30h                ;填空⑨(前面pop过了，我感觉这里是add  CITYOUT+6,30h)
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           mov    cx, 16                       ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                 
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-2读程序题

1.❀处的标号START作用是什么？（2分）
START是程序的入口标号，标志程序从这里开始执行，并作为程序入口点被汇编器用在 END START 指令中，指定程序从此处开始运行。

2.GETT子程序的主要功能是什么？（请参看附录2）（2分）
GETT 子程序的功能是从 CMOS 实时时钟读取当前的时间（小时和分钟）。其中，高字节 AH 保存当前小时，低字节 AL 保存当前分钟。

3.请描述出IP指向甲、乙、丙、丁等四处时，堆栈段的使用情况，包括堆栈指针和相应存储单元的内容。（6分）
~~（看不下去了）~~

| 甲   |
| ---- |
|      |
|      |
| 0    |
| (ds) |

sp=0FFFCh

4.△处的语句作用是什么？为什么此处要使用BP寄存器？（2分）
语句作用：(bp+6是谁，想知道呜呜┭┮﹏┭┮)
(对啊，是谁啊？/(ㄒoㄒ)/~~)
```MOV DX, [BP+6]```将堆栈中参数的值加载到寄存器 DX 中。
其中,```[BP+6]```表示从栈帧中的参数地址读取数据。
使用 BP 的原因：
由于子程序执行时，SP 的值会随着入栈、出栈操作不断变化，而 BP 被固定用于指向当前栈帧，便于访问传入的参数和局部变量。

5.☆处的两个语句作用是什么？如果去掉会有什么影响？（2分）
作用：
PUSHF和POPF用于保存和恢复标志寄存器FLAGS的状态。
这两个指令确保在循环左移ROL和条件判断JNZ时，标志寄存器的原始状态不受破坏。
去掉的影响：
如果没有PUSHF和POPF，标志寄存器的状态可能在子程序中被错误修改，导致循环条件或程序逻辑出错。

6.NOW子程序的主要功能是什么？（2分）
根据输入的时间信息和城市时区差异，计算并显示当前的城市时间（以 "HH:MM" 格式输出）。

7.丁处指令的功能是什么？（2分）

（书P207,ret的本质是pop sp,此处ret 4是在pop ip的基础上再pop sp+2,pop sp+4，但是我不知道这两个参数是谁）
所以是谁呀？
```RET 4```指令用于从子程序返回，同时清理调用时传入的 4 字节参数。调用者堆栈的指针自动调整，避免手动释放参数。

8.此程序的完整功能是什么?请简要描述,并用合适的自拟输入内容演示程序行后可能输出的典型结果(GETT子程序功能请参看附录)(2分)

程序功能：
该程序提示用户输入一个城市名称，查找对应城市的时区信息，根据当前时间（由 CMOS 提供）计算并显示城市的本地时间。如果输入的城市未找到，则输出默认消息 "I DO NOT KNOW :("。

典型结果：
输入：BEIJING
输出：UMT+8 BEIJING, CHINA 13:45

## 2023-3编程计算题

请编写程序段，实现运算（A*B+2024）/C+D*E，其中A、B、C、D、E均为有符号数字型变量名。程序必须考虑运算导致的字长改变（余数不计），并请说明你的最终运算结果字长。

```asm
datarea segment
        a       dw 506
        b       dw 4
        cc      dw 2          ;在真实的汇编语言编程中，c是一个关键字，会报错。但是考试还得怎么写
        d       dw 3
        e       dw 4
        ;这里的实例答案应该是07f4h
datarea ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea
        start:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                mov    ds,ax
            
        ;(A*B+2024)/C+D*E
        ;考试从这儿开始写
                mov    ax,a
                mov    bx,b
                imul   bx                           ;(dx:ax)=ax*bx=a*b
                add    ax,2024                      ;(dx:ax)=a*b+2024
                adc    dx,0
                mov    bx,cc
                idiv   bx                           ;(dx:ax)/bx=ax...dx
                mov    bx,ax
                mov    ax,d
                mov    cx,e
                imul   cx                           ;(dx:ax)=ax*cx=d*e
                add    ax,bx
                adc    dx,0
        ;结果存在(dx:ax)里
        ;考试从这儿结束
                ret
main endp
prognam ends
end start
```

## 2023-4编程循环题

请编写完整程序实现新同学插入原班级名单并显示的功能。设班级名单为N个单元的数组，每个单元有10个字节。其中第一个字节存放着学号，其余9个字节存放学生英文姓名。假定起始时名单中已有n个同学，学号已按照姓名字母为序升序排列，现再从键盘接收一个姓名的输入，并插入已有名单。

```asm
datarea segment
    arr     db 1,'daniel   '
            db 2,'joana    '
            db 3,'misaka   '
            db 4,'xxw      '
            db 5,'zeyuwang '
            db 10 dup(?)
    n       db 5
    buf     db 9,?,9 dup(' ')
datarea ends
prognam segment
main proc far
            assume cs:prognam,ds:datarea,es:datarea
    start:  
            push   ds
            sub    ax,ax
            push   ax
            mov    ax,datarea
            mov    ds,ax
            mov    es,ax

    ;输入新的姓名
            lea    dx,buf
            mov    ah,0ah
            int    21h
            call   crlf

            mov    bx,1
            sub    dx,dx
    search: 
    ;比较
    ; push   dx
    ; add    dl,30h
    ; mov    ah,02h
    ; int    21h
    ; pop    dx
            lea    di,buf[2]
            lea    si,arr[bx]
            mov    cl,buf[1]
            cld
            repe   cmpsb
            jge    find
            inc    dl
            add    bx,10
            cmp    dl,n
            jge    find
            jmp    search
            
    ;找到了,插入排序。dh放当前索引，bx放实际偏移地址
    find:   
            mov    al,n
            mov    dh,10
            mul    dh                                  ;ax=10*n
            mov    bx,ax
            mov    dh,n
    ;后边数都往前挪
    sort:   
            cmp    dh,dl
            jle    insert
            push   dx
            lea    si,arr[bx-10]
            lea    di,arr[bx]
            mov    cl,10
            cld
            rep    movsb
            inc    arr[bx]
            pop    dx
            sub    bx,10
            dec    dh
            jmp    sort
    insert: 
    ;用空格先填充
            lea    di, arr[bx+1]
            mov    al, ' '
            mov    cx, 9
            cld
            rep    stosb
    ;填入新的索引
            mov    arr[bx],dh
            inc    arr[bx]
    ;将名字插入
            lea    si,buf[2]
            lea    di,arr[bx+1]
            mov    cl,buf[1]
            cld
            rep    movsb
            inc    n                                   ;总数加1
            call   output
            ret
main endp
output proc
            sub    bx,bx
            sub    cl,cl
    o1:     
            mov    si,1
            mov    dl,arr[bx]                          ;懒了，按一位数算
            add    dl,30h
            mov    ah,2
            int    21h
            mov    dl,' '
            mov    ah,2
            int    21h
    o2:     
            mov    dl,arr[bx+si]
            mov    ah,2
            int    21h
            inc    si
            cmp    si,10
            jl     o2
            call   crlf
            inc    cl
            add    bx,10
            cmp    cl,n
            jl     o1
            ret
output endp
crlf proc
            push   dx
            mov    dl,0dh
            mov    ah,02h
            int    21h
            mov    dl,0ah
            mov    ah,02h
            int    21h
            pop    dx
            ret
crlf endp
prognam ends
end start
```

## 2023-5编程中断题

请完整程序采用接管1CH中断的方法实现在一小时倒计时的功能。程序开始时从59分59秒开始倒计时，每秒刷新一次时间。当计时回到00:00时重新从59:59开始倒计时。

## 2023附录

附录1：DOS系统功能调用（INT 21H）

| AH  | 功能             | 调用参数                                       | 返回参数                  |
| --- | ---------------- | ---------------------------------------------- | ------------------------- |
| 01  | 键盘输入并回显   |                                                | AL=输入的字符             |
| 02  | 显示输出         | DL=输出字符                                    |                           |
| 09  | 显示字符串       | DS：DX=串地址，串以'$'结束                     |                           |
| 0A  | 键盘输入到缓冲区 | DS：DX=缓冲区首址<br>(DS：DX)=缓冲区最大字符数 | (DS：DX)=实际输入的字符数 |
| 25  | 设置中断向量     | DS：DX=中断向量<br>AL=中断类型号               |                           |
| 35  | 取中断向量       | AL=中断类型号                                  | ES：BX=中断向量           |

1CH中断每秒钟约产生18次

附录2：CMOS RAM 中的时间信息

| 单元 | 存放内容 |
| ---- | -------- |
| 0    | 秒       |
| 2    | 分       |
| 4    | 时       |
| 7    | 日       |
| 8    | 月       |
| 9    | 年       |

这些数据以BCD码的方式存放。

从CMOS RAM 中读取信息的方式是：

```
OUT 70H, XX ; XX 为要访问的单元地址
IN AL, 71H   ; 从单元处读取数据
```
