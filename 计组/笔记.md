# 计算机组成原理

## 简答题

### 第二章

+ 小阶向大阶对齐的原因：
    减小误差
+ $[x]_补+[y]_补=[x+y]_补$的证明
    补码加法的公式为：
    $$[x]_补+[y]_补=[x+y]_补 (mod 2)$$
    证明：设x和y均为定点小数，且运算结果没有溢出。即$︱x︱﹤1，︱y︱﹤1，︱x+y︱﹤1$
    + （1）x﹥0，y﹥0，则x+y﹥0。正数的补码和原码是一样的，可得：
    [x]补+[y]补=x+y=[x+y]补 (mod 2)
    + （2）x﹥0，y﹤0，x+y≥0或x+y﹤0。
    [x]补=x，
    [y]补=2+y
    [x]补+[y]补=x+2+y=2+(x+y)
      + 当x+y≥0时，2 +(x+y) ≥2，对于模2来说，2被丢掉，于是
      [x]补+[y]补=x+y=[x+y]补 (mod 2)
      + 当x+y﹤0时，2 +(x+y) ﹤2，于是
      [x]补+[y]补=2+(x+y)=[x+y]补
      (mod 2)
    + （3）x﹤0，y﹥0。
    这种情况和第2种情况证明方法相同。
    + （4）x﹤0，y﹤0，则x+y﹤0。
    [x]补=2+x，
    [y]补=2+y
    [x]补+[y]补=2+x+2+y=2+(2+x+y)
    (2+x+y) 小于2而大于1的数，第一个2作为进位被舍弃。于是
    [x]补+[y]补=2+(x+y)=[x+y]补 (mod 2)
    至此我们证明了在模2意义下，两数的补码之和等于这两个数之和的补码。
+ 什么叫溢出？
    超出了机器的表示范围
+ 计算机内部为什么大部分
+ 全加器公式

    $$S=A⊕B⊕C$$

    $$C=AB+BC+AC$$

+ 全加器的时间延迟
+ 行波进位补码加法器为什么m=0为加法，m=1为减法？
+ 默写对2求补电路
    ![alt text](images/2.png)
+ 直接补码阵列乘法器
    最高位权值-1
+ 间接补码阵列乘法器
    算前求补的目的：补码变原码，扣掉符号位
    算后求补的目的：原码变补码，存入计算器
+ 原码除法：符号位单独运算
+ 阵列除法器CAS用的是加减交替法
+ ALU电路的基本概念
+ 先行进位
+ 流水线特点：并行进行运算，速度快

### 第三章

+ cache的目的
+ 高速缓存的目的
+ 双译码结构优点
    减少线的数目
+ 刷新->行
+ 地址复用技术
+ CDRAM DRAM里放一个SRAM
    SRAM->静态存储器，比较小但快
    DRAM->动态存储器
    读取时高位不变，低9位连续变化
    在SRAM读出期间同时对DRAM阵列进行刷新
    写和读可以同时
+ SDRAM：同步DRAM-CPU在SDRAM执行请求CPU同时，CPU能先去做别的
+ DDR SDRAM：上升沿和下降沿均可读数据
+ SRAM和DRAM

    ||SRAM|DRAM|
    |---|---|---|
    |存储容量|小|大|
    |速度|快|慢|
    |价格|贵|便宜|
    |缓冲|高速缓冲|需要刷新|
